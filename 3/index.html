<tt>
<h2>NES homebrew tools, step 3: tile editor</h2>
<p>NES games expose two 4kb graphic banks (CHR-ROM) to the PPU.
<br>Each bank can either represent 256 8*8px tiles or 128 8*16px sprites.
<br>The editor below shows these two views. Click a tile to edit it.
<br>Tiles can use 4 colors (depending on the palettes used). Color 0 = transparent.
<br>
<br>
<br>
<table>
<tr>
<th>View 1: 8x8px tiles
<th>View 2: 8x16px sprites
<th>Editor <span id=info style="font-weight:normal">(tile 0-0 / sprite 0)</span> 
<tr>
<td>
<canvas id=c1 width=256 height=512></canvas>
<td>
<canvas id=c2 width=256 height=512></canvas>
<td>
<canvas id=c3 width=255 height=255></canvas>
<br>
<br>
Color:
<button id=color0 style="padding:5px 10px;background:#000;color:#fff;border:4px solid #F00">0</button>
<button id=color1 style="padding:5px 10px;background:#555;color:#fff;border:4px solid #888">1</button>
<button id=color2 style="padding:5px 10px;background:#aaa;border:4px solid #888">2</button>
<button id=color3 style="padding:5px 10px;background:#fff;border:4px solid #888">3</button>
<br><br>
Reset: <button id=clear>tile</button> <button id=clearall>all</button>
/
Add: <button id=numbers>0-9</button> <button id=alphabet>A-Z</button>

<p>

Save/load:

<p><textarea id=output>00</textarea>

</table>



<style>
* { box-sizing: border-box; }
body { user-select: none }
table { min-width: 835px }
canvas { background: #000; border:1px solid #000;cursor: crosshair}
td { vertical-align: top; width: 275px; }
th { font-size: 14px }
th span { font-size: 11px }
button { cursor: pointer }
textarea { width: 240px; height: 130px; padding: 5px 10px; }
</style>

<script>
x1 = c1.getContext("2d");
x2 = c2.getContext("2d");
x3 = c3.getContext("2d");

t = 0; // current tile (0-511)

grid = () => {
  x1.fillStyle =
  x2.fillStyle =
  x3.fillStyle = "#f99";
  for(i = 0; i < 32; i++){
    x1.fillRect(i*16 - .5, - .5, .5, 512);
    x2.fillRect(i*16 - .5, - .5, .5, 512);
    x3.fillRect(i*32 - .5, - .5, .5, 512);
    x1.fillRect(-.5, i*16 - .5, 512, .5);
    x2.fillRect(-.5, i*32 - .5, 512, .5);
    x3.fillRect(-.5, i*32 - .5, 512, .5);
  }
  x1.fillStyle = "#9F9";
  x1.fillRect(0,256-.5,256,.5);
  
  lx = t % 16;
  ly = t / 16 | 0;
  
  x1.strokeStyle = "#f00";
  x1.rect(lx*16+.5,ly*16+.5,16,16);
  x1.stroke();
  
  ry = ly + (lx % 2) - (ly % 2);
  rx = lx / 2 | 0 + (ly % 2) * 8;
  
  
  x2.strokeStyle = "#f00";
  x2.rect(rx*16+.5,ry*16+.5,16,16);
  x2.stroke();
  
};

grid();

px = [];
bin = [];

reset = (i,j) => {
  px = [];
  bin = [];
  for(i = 0; i < 512; i++){
    px[i] = [];
    bin[i] = [];
    output.innerHTML = "00 ".repeat(8*1024).replace(/.{24}/g,"$&\n");
    for(j = 0; j < 16; j++){
      bin[i][j] = 0;
    }
    for(j = 0; j < 64; j++){
      px[i][j] = 0;
    }
  }
}

reset();

cols = ["#000","#555","#aaa","#fff"];

render = (i, j, x, y, col, lx, ly, rx, ry) => {

  // for each tile
  for(i in px){
  
    lx = (+i) % 16;
    ly = (+i) / 16 | 0;
    
    ry = ly + (lx % 2) - (ly % 2);
    rx = lx / 2 | 0 + (ly % 2) * 8;
    
    // For each pixel
    for(j in px[i]){
      x = j % 8;
      y = j / 8 | 0;
      col = cols[px[i][j]];
      x1.fillStyle = x2.fillStyle = x3.fillStyle = col;
      x1.fillRect(lx*16 + x*2, ly*16 + y*2, 2, 2);
      x2.fillRect(rx*16 + x*2, ry*16 + y*2, 2, 2);
      if(i == t) x3.fillRect(x*32, y*32, 32, 32);
      if(i == 0 && px[i][j] > 1){
        bin[i][y] |= 1 << (7 - x);
      }
      if(i == 0 && px[i][j] % 2){
        bin[i][y+8] |= 1 << (7 - x);
      }
    }
  }
}

pick = (tile, lx, ly, rx, ry) => {

  t = tile;
  
  lx = (+tile) % 16;
  ly = (+tile) / 16 | 0;
  
  ry = ly + (lx % 2) - (ly % 2);
  rx = lx / 2 | 0 + (ly % 2) * 8;
  
  c1.width ^= 0;
  c2.width ^= 0;
  c3.width ^= 0;
  render();
  grid();
  
  info.innerHTML = `(tile ${ly > 16 ? 1 : 0}-${(ly % 16) * 16 + lx} / sprite ${(ry / 2 | 0) * 16 + rx})`;
}

pick(0,0);

c1.onclick = (e, x, y) => {
  x = e.offsetX;
  y = e.offsetY;
  
  x = (~~(x/16));
  y = (~~(y/16));
  
  pick(y * 16 + x);
}

c2.onclick = (e, x, y) => {
  x = e.offsetX;
  y = e.offsetY;
  
  x = (~~(x/16));
  y = (~~(y/16));
  
  pick(
    (y % 2)
    ? ((y-1) * 16 + ((x * 2) % 16) + (x >= 8 ? 16 : 0) + 1)
    : (y * 16 + ((x * 2) % 16) + (x >= 8 ? 16 : 0))
  );
}

col = 0;
color0.onclick = () => {
  col = 0;
  color0.style.border = "4px solid #f00";
  color1.style.border = "4px solid #888";
  color2.style.border = "4px solid #888";
  color3.style.border = "4px solid #888";
}
color1.onclick = () => {
  col = 1;
  color1.style.border = "4px solid #f00";
  color0.style.border = "4px solid #888";
  color2.style.border = "4px solid #888";
  color3.style.border = "4px solid #888";
}
color2.onclick = () => {
  col = 2;
  color2.style.border = "4px solid #f00";
  color0.style.border = "4px solid #888";
  color1.style.border = "4px solid #888";
  color3.style.border = "4px solid #888";
}
color3.onclick = () => {
  col = 3;
  color3.style.border = "4px solid #f00";
  color0.style.border = "4px solid #888";
  color1.style.border = "4px solid #888";
  color2.style.border = "4px solid #888";
}

md = 0;
onmousedown = () => md = 1;
onmouseup = () => {
  md = 0;
  output.innerHTML = bin.map(x=>x.map(x=>x.toString(16).padStart(2,0)).join(" ")).join(" ").replace(/.{24}/g,"$&\n");
}

onmousemove = (e, x, y) => { 
  if(md && e.target.id === "c3"){
    x = e.offsetX/32|0;
    y = e.offsetY/32|0;
    trace(t, col, x, y);
  }
}

onclick = (e, x, y) => { 
  if(e.target.id === "c3"){
    x = e.offsetX/32|0;
    y = e.offsetY/32|0;
    trace(t, col, x, y);
    output.innerHTML = bin.map(x=>x.map(x=>x.toString(16).padStart(2,0)).join(" ")).join(" ").replace(/.{24}/g,"$&\n");
  }
}


trace = (tile, col, x, y) => {
  if(px[tile][y*8+x] != col){
    px[tile][y*8+x] = col;
    c1.width ^= 0;
    c2.width ^= 0;
    c3.width ^= 0;
    render();
    grid();
  }
}

clear.onclick = () => {
  px[t] = [];
  bin[t] = [];
  c1.width ^= 0;
  c2.width ^= 0;
  c3.width ^= 0;
  render();
  grid();
}

clearall.onclick = (i) => {
  if(confirm("Are you sure?")){
    reset();
    c1.width ^= 0;
    c2.width ^= 0;
    c3.width ^= 0;
    render();
    grid();
  }
}

output.oninput = () => {
  console.log("input");
}
</script>